console.log('üîµ CARGANDO functions_darwin.js...');

/**
 * ============================================
 * NIVEL 4: CLUSTER - C√öMULO DE GALAXIAS
 * Creado por: Darwin
 * CHECKPOINT: Todo funcionando + ajuste de distancia final
 * ============================================
 */

class ClusterLevelDarwin {
  constructor() {
    this.name = 'Cluster Galaxy Level';
    this.key = 'cluster';
    
    // Obtener rangos de la configuraci√≥n centralizada
    const clusterConfig = window.getLevelByKey 
      ? window.getLevelByKey('cluster-galaxy-Mpc') 
      : null;
    
    if (clusterConfig) {
      this.minSize = clusterConfig.min;
      this.maxSize = clusterConfig.max;
      this.backgroundColor = clusterConfig.backgroundColor || 0x800080;
      console.log(`üåå Cluster Level: ${this.minSize}-${this.maxSize}`);
    } else {
      console.warn('‚ö†Ô∏è No se encontr√≥ configuraci√≥n de cluster, usando valores por defecto');
      this.minSize = 60;
      this.maxSize = 100;
      this.backgroundColor = 0x800080;
    }
    
    this.active = false;
    this.botsSpawned = false;
    this.spawnSizeThreshold = 70;
    
    // Sistema de p√©rdida de control
    this.lostControl = false;
    this.targetCenter = { x: 0, y: 0 };
    this.moveSpeed = 3;
    
    // üÜï NUEVO: Distancia de seguridad y estado final
    this.safeDistance = 400; // Distancia m√≠nima al centro (en p√≠xeles)
    this.reachedCenter = false; // Si ya lleg√≥ al centro
    this.levelCompleted = false; // Si complet√≥ el nivel
    
    // Sistema de sprite personalizado del jugador
    this.customPlayerTexture = null;
    this.textureLoaded = false;
    
    // Texturas de los bots (ahora con m√°s variedad)
    this.botTextures = [];
    this.botTexturesLoaded = false;
    this.botTexturePaths = [
      '/assets/andromeda.webp',
      '/assets/brazos_azules.webp',
      '/assets/enana_esferica.webp',
      '/assets/exotic_galaxy.webp',
      '/assets/peque√±a_espiral.webp',
      '/assets/via_lactea.webp'
    ];
    
    console.log('‚úÖ ClusterLevelDarwin creado');
    console.log(`üìä Rango del nivel: ${this.minSize} - ${this.maxSize}`);
    console.log(`ü§ñ Bots se spawnear√°n a tama√±o: ${this.spawnSizeThreshold}`);
    console.log(`üõ°Ô∏è Distancia de seguridad: ${this.safeDistance}px`);
    
    // Cargar texturas
    this.loadCustomTexture();
    this.loadBotTextures();
  }

  /**
   * Cargar textura del c√∫mulo globular para el jugador
   */
  loadCustomTexture() {
    const textureKey = 'cumulo_globular_darwin';
    const texturePath = '/assets/cumulo_glubular.webp';
    
    console.log('üîÑ Intentando cargar textura del jugador:', texturePath);
    
    // Verificar si ya est√° cargada
    if (PIXI.utils.TextureCache[texturePath]) {
      this.customPlayerTexture = PIXI.utils.TextureCache[texturePath];
      this.textureLoaded = true;
      console.log('‚úÖ Textura del jugador ya estaba cargada');
      return;
    }
    
    // Cargar textura
    const texture = PIXI.Texture.from(texturePath);
    
    // Verificar cuando est√© lista
    if (texture.baseTexture.valid) {
      this.customPlayerTexture = texture;
      this.textureLoaded = true;
      console.log('‚úÖ Textura del jugador cargada inmediatamente');
    } else {
      texture.baseTexture.on('loaded', () => {
        this.customPlayerTexture = texture;
        this.textureLoaded = true;
        console.log('‚úÖ Textura del jugador cargada exitosamente');
        
        // Si ya entramos al nivel, activar sprite ahora
        if (this.active) {
          console.log('üîÑ Activando sprite despu√©s de carga...');
          this.activateCustomPlayerSprite();
        }
      });
      
      texture.baseTexture.on('error', () => {
        console.error('‚ùå Error cargando textura del jugador:', texturePath);
      });
    }
  }

  /**
   * Cargar texturas de los bots
   */
  loadBotTextures() {
    console.log('üîÑ Cargando texturas de bots...');
    
    let loadedCount = 0;
    const totalTextures = this.botTexturePaths.length;
    
    this.botTexturePaths.forEach((path, index) => {
      console.log(`üîÑ Cargando bot texture ${index}:`, path);
      
      // Verificar si ya est√° cargada
      if (PIXI.utils.TextureCache[path]) {
        this.botTextures[index] = PIXI.utils.TextureCache[path];
        loadedCount++;
        console.log(`‚úÖ Bot texture ${index} ya estaba cargada:`, path);
        
        if (loadedCount === totalTextures) {
          this.botTexturesLoaded = true;
          console.log('‚úÖ‚úÖ‚úÖ TODAS las texturas de bots cargadas!');
        }
        return;
      }
      
      // Cargar textura
      const texture = PIXI.Texture.from(path);
      
      // Verificar cuando est√© lista
      if (texture.baseTexture.valid) {
        this.botTextures[index] = texture;
        loadedCount++;
        console.log(`‚úÖ Bot texture ${index} cargada inmediatamente:`, path);
        
        if (loadedCount === totalTextures) {
          this.botTexturesLoaded = true;
          console.log('‚úÖ‚úÖ‚úÖ TODAS las texturas de bots cargadas!');
        }
      } else {
        texture.baseTexture.on('loaded', () => {
          this.botTextures[index] = texture;
          loadedCount++;
          console.log(`‚úÖ Bot texture ${index} cargada exitosamente:`, path);
          
          if (loadedCount === totalTextures) {
            this.botTexturesLoaded = true;
            console.log('‚úÖ‚úÖ‚úÖ TODAS las texturas de bots cargadas!');
          }
        });
        
        texture.baseTexture.on('error', () => {
          console.error(`‚ùå Error cargando bot texture ${index}:`, path);
        });
      }
    });
  }

  /**
   * Asignar texturas a todos los bots existentes en el mapa
   */
  assignTexturesToExistingBots() {
    const game = window.game;
    if (!game || !game.clientGameState || !game.clientGameState.players) {
      console.warn('‚ö†Ô∏è No hay estado del juego disponible');
      return;
    }

    if (!this.botTexturesLoaded) {
      console.warn('‚ö†Ô∏è Texturas de bots no est√°n cargadas todav√≠a');
      return;
    }

    const players = game.clientGameState.players;
    let botsFound = 0;

    console.log('üîç Buscando bots existentes en el mapa...');

    // Recorrer todos los jugadores
    Object.values(players).forEach(player => {
      // Solo aplicar a bots, no a jugadores reales
      if (player.isBot && player.isAlive) {
        // Asignar textura aleatoria
        const randomIndex = Math.floor(Math.random() * this.botTextures.length);
        const texture = this.botTextures[randomIndex];
        
        if (texture && texture.baseTexture.valid) {
          // Inicializar objetos si no existen
          if (!game.renderer.customBotSprites) {
            game.renderer.customBotSprites = {};
          }
          if (!game.renderer.customBotTextures) {
            game.renderer.customBotTextures = {};
          }
          
          // Asignar textura
          game.renderer.customBotTextures[player.id] = texture;
          botsFound++;
          
          console.log(`‚úÖ Bot ${player.id} asignado con textura ${randomIndex} (${this.botTexturePaths[randomIndex]})`);
        }
      }
    });

    console.log(`üé® Total de bots con textura asignada: ${botsFound}`);
  }

  /**
   * Registrar texturas de los 4 bots de las esquinas
   */
  registerBotTextures(botIds) {
    const game = window.game;
    if (!game || !game.renderer) {
      console.error('‚ùå No hay game o renderer');
      return;
    }
    
    console.log('üé® Registrando texturas de bots de las esquinas:', botIds);
    console.log('üé® Texturas disponibles:', this.botTextures.length);
    console.log('üé® Texturas cargadas:', this.botTexturesLoaded);
    
    // Inicializar objetos si no existen
    if (!game.renderer.customBotSprites) {
      game.renderer.customBotSprites = {};
    }
    if (!game.renderer.customBotTextures) {
      game.renderer.customBotTextures = {};
    }
    
    // Usar las primeras 4 texturas para los bots de las esquinas
    botIds.forEach((botId, index) => {
      if (this.botTextures[index] && this.botTextures[index].baseTexture.valid) {
        game.renderer.customBotTextures[botId] = this.botTextures[index];
        console.log(`‚úÖ Bot de esquina ${index} (${botId}) registrado con textura`);
      } else {
        console.error(`‚ùå No hay textura v√°lida para bot ${index}`);
      }
    });
    
    console.log('üé® Texturas de bots de esquinas registradas en renderer');
  }

  /**
   * Activar sprite personalizado para el jugador
   */
  activateCustomPlayerSprite() {
    const game = window.game;
    
    console.log('üîç Verificando activaci√≥n de sprite:', {
      game: !!game,
      renderer: !!game?.renderer,
      myPlayerId: game?.myPlayerId,
      texture: !!this.customPlayerTexture,
      textureValid: this.customPlayerTexture?.baseTexture?.valid
    });
    
    if (!game || !game.renderer || !game.myPlayerId) {
      console.error('‚ùå No se puede activar sprite: falta game, renderer o playerId');
      return;
    }
    
    if (!this.customPlayerTexture || !this.customPlayerTexture.baseTexture.valid) {
      console.warn('‚ö†Ô∏è Textura personalizada no est√° lista a√∫n');
      return;
    }
    
    // Activar flags en el renderer
    game.renderer.useCustomPlayerSprite = true;
    game.renderer.customPlayerTexture = this.customPlayerTexture;
    game.renderer.customPlayerId = game.myPlayerId;
    
    console.log('‚úÖ Sprite personalizado activado para jugador:', game.myPlayerId);
    console.log('‚úÖ Flags del renderer:', {
      useCustomPlayerSprite: game.renderer.useCustomPlayerSprite,
      customPlayerId: game.renderer.customPlayerId,
      hasTexture: !!game.renderer.customPlayerTexture
    });
  }

  /**
   * Desactivar sprite personalizado
   */
  deactivateCustomPlayerSprite() {
    const game = window.game;
    if (!game || !game.renderer) return;
    
    game.renderer.useCustomPlayerSprite = false;
    game.renderer.customPlayerTexture = null;
    game.renderer.customPlayerId = null;
    
    // Limpiar sprite si existe
    if (game.renderer.customPlayerSprite) {
      game.renderer.customPlayerSprite.destroy();
      game.renderer.customPlayerSprite = null;
    }
    
    // Limpiar sprites de bots
    if (game.renderer.customBotSprites) {
      Object.values(game.renderer.customBotSprites).forEach(sprite => {
        if (sprite && sprite.destroy) sprite.destroy();
      });
      game.renderer.customBotSprites = {};
    }
    
    // Limpiar texturas de bots
    if (game.renderer.customBotTextures) {
      game.renderer.customBotTextures = {};
    }
    
    console.log('‚úÖ Sprite personalizado y bots desactivados');
  }

  /**
   * Se ejecuta cuando el jugador entra al nivel 4
   */
  onEnter() {
    console.log('üååüååüåå ¬°¬°¬°ENTRASTE AL CLUSTER GALAXY!!! üååüååüåå');
    console.log('üìç onEnter() ejecutado');
    
    this.active = true;
    this.changeBackgroundColor();
    this.showLevelMessage('CLUSTER GALAXY - Nivel 4');
    
    // Activar sprite personalizado si la textura ya est√° cargada
    console.log('üîç Estado de textura:', {
      loaded: this.textureLoaded,
      texture: !!this.customPlayerTexture
    });
    
    if (this.textureLoaded && this.customPlayerTexture) {
      this.activateCustomPlayerSprite();
    } else {
      console.warn('‚ö†Ô∏è Textura a√∫n no est√° lista, se activar√° cuando cargue');
    }

    // Asignar texturas a todos los bots existentes
    if (this.botTexturesLoaded) {
      console.log('üé® Asignando texturas a bots existentes...');
      this.assignTexturesToExistingBots();
    } else {
      console.warn('‚ö†Ô∏è Texturas de bots no est√°n listas todav√≠a');
    }
    
    // Escuchar respuesta del servidor cuando spawnen los bots de las esquinas
    const game = window.game;
    if (game && game.socket && game.socket.socket) {
      console.log('‚úÖ Registrando listener para darwinBotsSpawned');
      
      game.socket.socket.on('darwinBotsSpawned', (data) => {
        console.log('üéØüéØüéØ Bots spawneados! Centro:', data.centerX, data.centerY);
        console.log('üì¶ Datos recibidos:', data);
        
        this.targetCenter.x = data.centerX;
        this.targetCenter.y = data.centerY;
        this.lostControl = true;
        
        // Registrar texturas de bots de las esquinas
        if (data.botIds && this.botTexturesLoaded) {
          console.log('üé® Registrando texturas de bots de esquinas...');
          this.registerBotTextures(data.botIds);
        } else {
          console.warn('‚ö†Ô∏è No se pudieron registrar texturas de bots:', {
            hasBotIds: !!data.botIds,
            texturesLoaded: this.botTexturesLoaded
          });
        }
        
        this.showLevelMessage('‚ö†Ô∏è ATRACCI√ìN GRAVITACIONAL ‚ö†Ô∏è');
      });
    } else {
      console.error('‚ùå No se pudo registrar listener: game o socket no disponible');
    }
  }

  /**
   * Se ejecuta cuando el jugador sale del nivel 4
   */
  onExit() {
    console.log('üëãüëãüëã SALIENDO DEL CLUSTER GALAXY üëãüëãüëã');
    this.active = false;
    this.restoreBackgroundColor();
    this.botsSpawned = false;
    this.lostControl = false;
    this.reachedCenter = false;
    this.levelCompleted = false;
    
    // Desactivar sprite personalizado
    this.deactivateCustomPlayerSprite();
    
    const game = window.game;
    if (game && game.socket && game.socket.socket) {
      game.socket.socket.off('darwinBotsSpawned');
    }
  }

  /**
   * Render: No dibuja nada (los bots son del servidor)
   */
  render(renderer, camera) {
    // Los bots son del servidor
  }

  /**
   * üÜï MODIFICADO: Update con distancia de seguridad
   */
  update(deltaTime) {
    const game = window.game;
    if (!game || !game.myPlayerId) return;
    
    const myPlayer = game.clientGameState.players[game.myPlayerId];
    if (!myPlayer || !myPlayer.isAlive) return;
    
    // DEBUG: Log peri√≥dico de tama√±o del jugador
    if (Math.random() < 0.01) {
      console.log(`üìè Tama√±o actual: ${myPlayer.size.toFixed(1)}, Nivel activo: ${this.active}`);
    }
    
    // Solicitar spawn de bots cuando alcance el tama√±o
    if (!this.botsSpawned && myPlayer.size >= this.spawnSizeThreshold) {
      console.log(`ü§ñü§ñü§ñ ¬°Size ${this.spawnSizeThreshold} alcanzado! Solicitando spawn... ü§ñü§ñü§ñ`);
      this.requestBotsSpawn();
    }
    
    // üÜï MODIFICADO: Mover hacia el centro pero detenerse a distancia segura
    if (this.lostControl && game.socket && game.socket.socket) {
      const dx = this.targetCenter.x - myPlayer.x;
      const dy = this.targetCenter.y - myPlayer.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // üÜï NUEVO: Si lleg√≥ a la distancia segura
      if (distance <= this.safeDistance) {
        if (!this.reachedCenter) {
          this.reachedCenter = true;
          console.log('üéâüéâüéâ ¬°LLEGASTE AL CENTRO! üéâüéâüéâ');
          console.log(`üõ°Ô∏è Distancia final: ${Math.round(distance)}px`);
          
          // Marcar nivel como completado
          this.levelCompleted = true;
          
          // Mostrar mensaje de victoria
          this.showVictoryMessage();
          
          // Desactivar control (ya no te mover√°s m√°s)
          this.lostControl = false;
        }
        
        return; // No mover m√°s
      }
      
      // Si a√∫n est√° lejos, seguir movi√©ndose
      if (distance > this.safeDistance + 5) { // +5 para evitar oscilaciones
        const moveX = (dx / distance) * this.moveSpeed;
        const moveY = (dy / distance) * this.moveSpeed;
        
        const newX = myPlayer.x + moveX;
        const newY = myPlayer.y + moveY;
        
        game.socket.sendMove(newX, newY);
        
        if (Math.random() < 0.016) {
          console.log(`üéØ Moviendo hacia centro: distancia=${Math.round(distance)}px`);
        }
      }
    }
  }

  /**
   * Solicitar al servidor que spawnee los bots
   */
  requestBotsSpawn() {
    this.botsSpawned = true;
    
    const game = window.game;
    if (game && game.socket && game.socket.socket) {
      console.log('üì° Enviando solicitud de spawn al servidor...');
      
      game.socket.socket.emit('spawnDarwinBots', { 
        playerId: game.myPlayerId,
        count: 4,
        size: 100
      });
      
      console.log('üì° Solicitud de spawn enviada al servidor');
    } else {
      console.error('‚ùå No se pudo enviar solicitud al servidor');
    }
  }

  /**
   * Cambiar fondo a morado
   */
  changeBackgroundColor() {
    if (window.game && window.game.renderer && window.game.renderer.app) {
      window.game.renderer.app.renderer.backgroundColor = this.backgroundColor;
      console.log('üé® Fondo cambiado a morado');
    } else {
      console.error('‚ùå No se pudo cambiar el fondo');
    }
  }

  /**
   * Restaurar fondo original
   */
  restoreBackgroundColor() {
    if (window.game && window.game.renderer && window.game.renderer.app) {
      window.game.renderer.app.renderer.backgroundColor = 0x0a0a0f;
      console.log('üé® Fondo restaurado');
    }
  }

  /**
   * Mostrar mensaje
   */
  showLevelMessage(message) {
    const messageDiv = document.createElement('div');
    messageDiv.textContent = message;
    messageDiv.style.position = 'fixed';
    messageDiv.style.top = '20%';
    messageDiv.style.left = '50%';
    messageDiv.style.transform = 'translate(-50%, -50%)';
    messageDiv.style.fontSize = '36px';
    messageDiv.style.fontWeight = 'bold';
    messageDiv.style.color = '#FF0000';
    messageDiv.style.textShadow = '0 0 30px #FF0000, 0 0 60px #FF0000';
    messageDiv.style.zIndex = '9999';
    messageDiv.style.pointerEvents = 'none';
    messageDiv.style.fontFamily = 'Arial, sans-serif';
    
    document.body.appendChild(messageDiv);
    
    setTimeout(() => {
      messageDiv.remove();
    }, 3000);
  }

  /**
   * üÜï NUEVO: Mostrar mensaje de victoria
   */
  showVictoryMessage() {
    const victoryDiv = document.createElement('div');
    victoryDiv.innerHTML = `
      <div style="font-size: 48px; margin-bottom: 20px;">üéâ ¬°NIVEL COMPLETADO! üéâ</div>
      <div style="font-size: 24px;">Has alcanzado el Gran Atractor</div>
      <div style="font-size: 18px; margin-top: 10px; opacity: 0.8;">Permaneces en √≥rbita estable</div>
    `;
    victoryDiv.style.position = 'fixed';
    victoryDiv.style.top = '30%';
    victoryDiv.style.left = '50%';
    victoryDiv.style.transform = 'translate(-50%, -50%)';
    victoryDiv.style.fontWeight = 'bold';
    victoryDiv.style.color = '#00FF00';
    victoryDiv.style.textShadow = '0 0 30px #00FF00, 0 0 60px #00FF00';
    victoryDiv.style.zIndex = '10000';
    victoryDiv.style.pointerEvents = 'none';
    victoryDiv.style.fontFamily = 'Arial, sans-serif';
    victoryDiv.style.textAlign = 'center';
    victoryDiv.style.padding = '30px';
    victoryDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    victoryDiv.style.borderRadius = '20px';
    victoryDiv.style.border = '3px solid #00FF00';
    
    document.body.appendChild(victoryDiv);
    
    // No remover autom√°ticamente - queda permanente
    console.log('üéä Mensaje de victoria mostrado');
  }

  /**
   * Limpiar recursos
   */
  cleanup() {
    this.restoreBackgroundColor();
    this.botsSpawned = false;
    this.lostControl = false;
    this.reachedCenter = false;
    this.levelCompleted = false;
    this.deactivateCustomPlayerSprite();
  }
}

// Exponer globalmente
window.DarwinClusterLevel = new ClusterLevelDarwin();

console.log('‚úÖ functions_darwin.js cargado completamente');
console.log('‚úÖ window.DarwinClusterLevel:', window.DarwinClusterLevel);